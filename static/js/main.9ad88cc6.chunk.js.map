{"version":3,"sources":["../../component-library/dist/esm-es5 lazy /^/.//.*/.entry/.js$/ include: //.entry/.js$/ exclude: //.system/.entry/.js$/ groupOptions: {} namespace object","../../component-library-react/dist/react-component-lib/utils/attachEventProps.js","../../component-library-react/dist/react-component-lib/createComponent.js","../../component-library-react/dist/react-component-lib/utils/index.js","../../component-library/loader/index.mjs","../../component-library/dist/esm/polyfills/index.js","../../component-library-react/dist/components.js","../../component-library/dist/esm-es5/loader.mjs","App.tsx","serviceWorker.ts","index.tsx","../../component-library/dist/esm-es5/core-fcb12969.js"],"names":["map","./accordion-container_2.entry.js","./demo-component.entry.js","webpackAsyncContext","req","ids","__webpack_require__","e","then","id","Promise","resolve","Error","code","keys","Object","module","exports","attachEventProps","node","newProps","oldProps","arguments","length","undefined","className","classList","currentClasses","arrayToMap","incomingPropClasses","split","oldPropClasses","finalClassNames","forEach","currentClass","has","push","delete","s","join","getClassName","name","indexOf","toUpperCase","eventName","substring","eventNameLc","toLowerCase","isCoveredByReact","newEventHandler","eventStore","__events","oldEventHandler","removeEventListener","addEventListener","call","this","syncEvent","eventNameSuffix","doc","document","isSupported","element","createElement","setAttribute","arr","Map","set","__rest","t","p","prototype","hasOwnProperty","getOwnPropertySymbols","i","createComponent_createReactComponent","tagName","displayName","segment","charAt","slice","ReactComponent","forwardRef","props","ref","node_modules_react_default","a","assign","forwardedRef","utils_createForwardRef","_React$Component","classCallCheck","possibleConstructorReturn","getPrototypeOf","inherits","createClass","key","value","componentDidUpdate","prevProps","node_modules_react_dom_default","findDOMNode","_a","children","style","cProps","propsToPass","reduce","acc","get","Component","window","Reflect","customElements","BuiltInHTMLElement","HTMLElement","construct","constructor","setPrototypeOf","win","promises","Element","closest","matches","remove","bind","entries","Array","find","includes","String","startsWith","endsWith","NodeList","fetch","u","URL","pathname","href","searchParams","checkIfURLIsSupported","WeakMap","all","applyPolyfills","options","core_fcb12969","heading","content","min","max","advanced","AccordionContainer","AccordionItem","App","_this","updateRangeValue","newValue","setState","removeSlider","newComps","state","comps","shift","_this2","react_default","onClick","_comp","slot","color","Boolean","location","hostname","match","ReactDOM","render","src_App_0","getElementById","navigator","serviceWorker","ready","registration","unregister","d","__webpack_exports__","patchEsm","bootstrapLazy","createEvent","h","registerInstance","scopeId","contentRef","hostTagName","__extends","_extendStatics","b","__proto__","__","create","__awaiter","thisArg","_arguments","P","generator","reject","fulfilled","step","next","rejected","result","done","apply","__generator","body","f","y","g","_","label","sent","trys","ops","verb","throw","return","Symbol","iterator","n","v","op","TypeError","pop","__spreadArrays","il","r","k","j","jl","queueCongestion","queuePending","useNativeShadowDom","checkSlotFallbackVisibility","checkSlotRelocate","plt","$flags$","$resourcesUrl$","jmp","raf","requestAnimationFrame","ael","el","listener","opts","rel","supportsShadowDom","documentElement","attachShadow","supportsConstructibleStylesheets","CSSStyleSheet","hostRefs","getHostRef","lazyInstance","hostRef","$lazyInstance$","registerHost","elm","$hostElement$","$instanceValues$","$onReadyPromise$","$onReadyResolve$","isMemberInElement","memberName","consoleError","console","error","moduleCache","styles","queueDomReads","queueDomWrites","queueDomWritesLow","queueTask","queue","write","cb","nextTick","flush","consumeTimeout","timeout","ts","performance","now","splice","consume","Math","ceil","Infinity","writeTask","EMPTY_OBJ","isComplexType","o","createTime","fnName","CSS","supports","$cssShim$","__stencil_cssshim","initShim","rootAppliedStyles","attachStyles","cmpMeta","mode","endAttachStyles","$tagName$","styleContainerNode","hostElm","getScopeId","nodeType","head","appliedStyles","styleElm","Set","newScopeId","createHostStyle","innerHTML","insertBefore","querySelector","add","adoptedStyleSheets","addStyle","shadowRoot","getRootNode","nodeName","vnodeData","_i","child","slotName","simple","lastSimple","vNodeChildren","walk","c","isArray","$text$","newVNode","classData_1","class","filter","vnode","$attrs$","$children$","$name$","tag","text","$tag$","$elm$","Host","setAccessor","oldValue","isSvg","flags","isProp","ln","oldClasses_1","parseClassList","newClasses_1","isComplex","removeAttribute","parseClassListRegex","updateElement","oldVnode","newVnode","isSvgMode","host","oldVnodeAttrs","newVnodeAttrs","createElm","oldParentVNode","newParentVNode","childIndex","parentElm","childNode","oldVNode","createTextNode","appendChild","putBackInOriginalLocation","recursive","oldSlotChildNodes","childNodes","parentReferenceNode","referenceNode","addVnodes","before","parentVNode","vnodes","startIdx","endIdx","containerElm","parentNode","removeVnodes","callNodeRefs","updateChildren","oldCh","newCh","oldStartIdx","newStartIdx","oldEndIdx","oldStartVnode","oldEndVnode","newEndIdx","newStartVnode","newEndVnode","isSameVnode","patch","nextSibling","vnode1","vnode2","defaultHolder","oldChildren","newChildren","textContent","data","relocateNodes","vNode","renderVdom","renderFnResults","$vnode$","rootVnode","relocateSlotContent","hostContentNodes","slotNameAttr","ilen","getAttribute","some","$nodeToRelocate$","$slotRefNode$","relocateNode","orgLocationNode","parentNodeRef","insertBeforeNode","previousSibling","refNode","updateFallbackSlotVisibility","hidden","trim","attachToAncestor","ancestorComponent","$onRenderResolve$","scheduleUpdate","isInitialLoad","endSchedule","$ancestorComponent$","instance","update","updateComponent","promise","endUpdate","rc","$modeName$","endRender","updateHost","childrenPromises","postUpdate","postUpdateComponent","endPostUpdate","appDidLoad","who","thenFn","setValue","propName","newVal","propValue","propType","oldVal","$members$","parseFloat","proxyComponent","Cstr","members","prototype_1","memberFlags","defineProperty","configurable","enumerable","attrNameToPropName_1","attributeChangedCallback","attrName","_oldValue","observedAttributes","initializeComponent","hmrVersionId","endLoad","endNewInstance","scopeId_1","endRegisterStyles","style_1","schedule","exportName","replace","bundleId","$lazyBundleIds$","importedModule","loadModule","isProxied","m","scopeCss","cssText","allowCS","registerStyle","setContentReference","contentRefElm","createComment","firstChild","lazyBundles","appLoadFallback","endBootstrap","cmpTags","exclude","visibilityStyle","deferredConnectedCallbacks","isBootstrapping","resourcesUrl","baseURI","syncQueue","lazyBundle","compactMeta","$listeners$","HostElement","_super","self","connectedCallback","clearTimeout","endConnected","hostRef_1","disconnectedCallback","removeHost","forceUpdate","componentOnReady","define","setTimeout","getElement","emit","detail","dispatchEvent","CustomEvent","bubbles","composed","cancelable"],"mappings":"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","file":"static/js/main.9ad88cc6.chunk.js","sourcesContent":["var map = {\n\t\"./accordion-container_2.entry.js\": [\n\t\t29,\n\t\t3\n\t],\n\t\"./demo-component.entry.js\": [\n\t\t30,\n\t\t5\n\t]\n};\nfunction webpackAsyncContext(req) {\n\tvar ids = map[req];\n\tif(!ids) {\n\t\treturn Promise.resolve().then(function() {\n\t\t\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\t\t\te.code = 'MODULE_NOT_FOUND';\n\t\t\tthrow e;\n\t\t});\n\t}\n\treturn __webpack_require__.e(ids[1]).then(function() {\n\t\tvar id = ids[0];\n\t\treturn __webpack_require__(id);\n\t});\n}\nwebpackAsyncContext.keys = function webpackAsyncContextKeys() {\n\treturn Object.keys(map);\n};\nwebpackAsyncContext.id = 20;\nmodule.exports = webpackAsyncContext;","export function attachEventProps(node, newProps) {\n  var oldProps = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var className = getClassName(node.classList, newProps, oldProps);\n\n  if (className) {\n    node.className = className;\n  }\n\n  Object.keys(newProps).forEach(function (name) {\n    if (name === 'children' || name === 'style' || name === 'ref' || name === 'className') {\n      return;\n    }\n\n    if (name.indexOf('on') === 0 && name[2] === name[2].toUpperCase()) {\n      var eventName = name.substring(2);\n      var eventNameLc = eventName[0].toLowerCase() + eventName.substring(1);\n\n      if (!isCoveredByReact(eventNameLc)) {\n        syncEvent(node, eventNameLc, newProps[name]);\n      }\n    } else {\n      node[name] = newProps[name];\n    }\n  });\n}\nexport function getClassName(classList, newProps, oldProps) {\n  // map the classes to Maps for performance\n  var currentClasses = arrayToMap(classList);\n  var incomingPropClasses = arrayToMap(newProps.className ? newProps.className.split(' ') : []);\n  var oldPropClasses = arrayToMap(oldProps.className ? oldProps.className.split(' ') : []);\n  var finalClassNames = []; // loop through each of the current classes on the component\n  // to see if it should be a part of the classNames added\n\n  currentClasses.forEach(function (currentClass) {\n    if (incomingPropClasses.has(currentClass)) {\n      // add it as its already included in classnames coming in from newProps\n      finalClassNames.push(currentClass);\n      incomingPropClasses.delete(currentClass);\n    } else if (!oldPropClasses.has(currentClass)) {\n      // add it as it has NOT been removed by user\n      finalClassNames.push(currentClass);\n    }\n  });\n  incomingPropClasses.forEach(function (s) {\n    return finalClassNames.push(s);\n  });\n  return finalClassNames.join(' ');\n}\n/**\n * Checks if an event is supported in the current execution environment.\n * @license Modernizr 3.0.0pre (Custom Build) | MIT\n */\n\nexport function isCoveredByReact(eventNameSuffix) {\n  var doc = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : document;\n  var eventName = 'on' + eventNameSuffix;\n  var isSupported = eventName in doc;\n\n  if (!isSupported) {\n    var element = doc.createElement('div');\n    element.setAttribute(eventName, 'return;');\n    isSupported = typeof element[eventName] === 'function';\n  }\n\n  return isSupported;\n}\nexport function syncEvent(node, eventName, newEventHandler) {\n  var eventStore = node.__events || (node.__events = {});\n  var oldEventHandler = eventStore[eventName]; // Remove old listener so they don't double up.\n\n  if (oldEventHandler) {\n    node.removeEventListener(eventName, oldEventHandler);\n  } // Bind new listener.\n\n\n  node.addEventListener(eventName, eventStore[eventName] = function handler(e) {\n    newEventHandler.call(this, e);\n  });\n}\n\nfunction arrayToMap(arr) {\n  var map = new Map();\n  arr.forEach(function (s) {\n    return map.set(s, s);\n  });\n  return map;\n}","import _classCallCheck from \"/Users/ps11/Documents/Projects/stencil-ds-plugins-demo/packages/app-react/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/ps11/Documents/Projects/stencil-ds-plugins-demo/packages/app-react/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"/Users/ps11/Documents/Projects/stencil-ds-plugins-demo/packages/app-react/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"/Users/ps11/Documents/Projects/stencil-ds-plugins-demo/packages/app-react/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"/Users/ps11/Documents/Projects/stencil-ds-plugins-demo/packages/app-react/node_modules/@babel/runtime/helpers/esm/inherits\";\n\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n\n  for (var p in s) {\n    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  }\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\n\nimport React from 'react';\nimport ReactDom from 'react-dom';\nimport { attachEventProps, createForwardRef, dashToPascalCase, isCoveredByReact } from './utils/index';\nexport var createReactComponent = function createReactComponent(tagName) {\n  var displayName = dashToPascalCase(tagName);\n\n  var ReactComponent =\n  /*#__PURE__*/\n  function (_React$Component) {\n    _inherits(ReactComponent, _React$Component);\n\n    function ReactComponent(props) {\n      _classCallCheck(this, ReactComponent);\n\n      return _possibleConstructorReturn(this, _getPrototypeOf(ReactComponent).call(this, props));\n    }\n\n    _createClass(ReactComponent, [{\n      key: \"componentDidMount\",\n      value: function componentDidMount() {\n        this.componentDidUpdate(this.props);\n      }\n    }, {\n      key: \"componentDidUpdate\",\n      value: function componentDidUpdate(prevProps) {\n        var node = ReactDom.findDOMNode(this);\n        attachEventProps(node, this.props, prevProps);\n      }\n    }, {\n      key: \"render\",\n      value: function render() {\n        var _a = this.props,\n            children = _a.children,\n            forwardedRef = _a.forwardedRef,\n            style = _a.style,\n            className = _a.className,\n            ref = _a.ref,\n            cProps = __rest(_a, [\"children\", \"forwardedRef\", \"style\", \"className\", \"ref\"]);\n\n        var propsToPass = Object.keys(cProps).reduce(function (acc, name) {\n          if (name.indexOf('on') === 0 && name[2] === name[2].toUpperCase()) {\n            var eventName = name.substring(2).toLowerCase();\n\n            if (isCoveredByReact(eventName)) {\n              acc[name] = cProps[name];\n            }\n          }\n\n          return acc;\n        }, {});\n        var newProps = Object.assign({}, propsToPass, {\n          ref: forwardedRef,\n          style: style,\n          className: className\n        });\n        return React.createElement(tagName, newProps, children);\n      }\n    }], [{\n      key: \"displayName\",\n      get: function get() {\n        return displayName;\n      }\n    }]);\n\n    return ReactComponent;\n  }(React.Component);\n\n  return createForwardRef(ReactComponent, displayName);\n};","import React from 'react';\nexport var dashToPascalCase = function dashToPascalCase(str) {\n  return str.toLowerCase().split('-').map(function (segment) {\n    return segment.charAt(0).toUpperCase() + segment.slice(1);\n  }).join('');\n};\nexport var generateUniqueId = function generateUniqueId() {\n  return ([1e7].toString() + -1e3.toString() + -4e3.toString() + -8e3.toString() + -1e11.toString()).replace(/[018]/g, function (c) {\n    var random = crypto.getRandomValues(new Uint8Array(1));\n    return (c ^ random[0] & 15 >> c / 4).toString(16);\n  });\n};\nexport var createForwardRef = function createForwardRef(ReactComponent, displayName) {\n  var forwardRef = function forwardRef(props, ref) {\n    return React.createElement(ReactComponent, Object.assign({}, props, {\n      forwardedRef: ref\n    }));\n  };\n\n  forwardRef.displayName = displayName;\n  return React.forwardRef(forwardRef);\n};\nexport * from './attachEventProps';","(function () {\n  if ( // No Reflect, no classes, no need for shim because native custom elements\n  // require ES2015 classes or Reflect.\n  window.Reflect === undefined || window.customElements === undefined) {\n    return;\n  }\n\n  var BuiltInHTMLElement = HTMLElement;\n\n  window.HTMLElement =\n  /** @this {!Object} */\n  function HTMLElement() {\n    return Reflect.construct(BuiltInHTMLElement, [],\n    /** @type {!Function} */\n    this.constructor);\n  };\n\n  HTMLElement.prototype = BuiltInHTMLElement.prototype;\n  HTMLElement.prototype.constructor = HTMLElement;\n  Object.setPrototypeOf(HTMLElement, BuiltInHTMLElement);\n})();\n\nexport * from '../dist/esm/polyfills/index.js';\nexport * from '../dist/esm-es5/loader.mjs';","export function applyPolyfills() {\n  var win = window;\n  var promises = [];\n\n  if (!win.customElements || win.Element && (!win.Element.prototype.closest || !win.Element.prototype.matches || !win.Element.prototype.remove)) {\n    promises.push(import('./dom.js'));\n  }\n\n  function checkIfURLIsSupported() {\n    try {\n      var u = new URL('b', 'http://a');\n      u.pathname = 'c%20d';\n      return u.href === 'http://a/c%20d' && u.searchParams;\n    } catch (e) {\n      return false;\n    }\n  }\n\n  if ('function' !== typeof Object.assign || !Object.entries || !Array.prototype.find || !Array.prototype.includes || !String.prototype.startsWith || !String.prototype.endsWith || win.NodeList && !win.NodeList.prototype.forEach || !win.fetch || !checkIfURLIsSupported() || typeof WeakMap == 'undefined') {\n    promises.push(import('./core-js.js'));\n  }\n\n  return Promise.all(promises);\n}","/* tslint:disable */\n\n/* auto-generated react proxies */\nimport { createReactComponent } from './react-component-lib';\nimport { defineCustomElements, applyPolyfills } from 'component-library/loader';\napplyPolyfills().then(function () {\n  defineCustomElements(window);\n});\nexport var AccordionContainer = createReactComponent('accordion-container');\nexport var AccordionItem = createReactComponent('accordion-item');\nexport var DemoComponent = createReactComponent('demo-component');","import { a as patchEsm, b as bootstrapLazy } from './core-fcb12969.js';\n\nvar defineCustomElements = function defineCustomElements(win, options) {\n  return patchEsm().then(function () {\n    bootstrapLazy([[\"accordion-container_2\", [[1, \"accordion-container\", {\n      \"heading\": [1]\n    }], [1, \"accordion-item\", {\n      \"heading\": [1],\n      \"content\": [1]\n    }]]], [\"demo-component\", [[1, \"demo-component\", {\n      \"min\": [2],\n      \"max\": [2],\n      \"advanced\": [16],\n      \"value\": [1025]\n    }]]]], options);\n  });\n};\n\nexport { defineCustomElements };","import React, { Component } from 'react';\nimport { AccordionContainer, AccordionItem } from 'component-library-react';\nimport './App.css';\n\ninterface State {\n  value: number | null;\n  comps: number[]\n}\n\nclass App extends Component<{}, State> {\n  constructor(props: {}) {\n    super(props);\n\n    this.state = {\n      value: null,\n      comps: [1, 2, 3, 4]\n    };\n  }\n\n  updateRangeValue = (newValue: number) => {\n    this.setState(() => ({\n      value: newValue\n    }));\n  };\n\n  removeSlider = () => {\n    let newComps = this.state.comps\n    newComps.shift()\n    this.setState(() => ({\n      comps: newComps\n    }));\n  }\n\n  render() {\n    return (\n      <div className=\"App\">\n        <header className=\"App-header\">\n          <button onClick={() => this.removeSlider()}>Remove Accordion</button>\n          <AccordionContainer heading=\"This is Heading\" >\n          {this.state.comps.map(_comp => {\n            return (\n              <AccordionItem heading=\"This is item Heading\" key={_comp}>\n                <p slot=\"content\" style={{color: 'black'}}>This is Content</p>\n              </AccordionItem>\n            )\n            })}\n          </AccordionContainer>\n          {this.state.value ? <p>Value is {this.state.value}</p> : null}\n        </header>\n      </div>\n    );\n  }\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      (process as { env: { [key: string]: string } }).env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n","var __extends = this && this.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) {\n        if (b.hasOwnProperty(p)) d[p] = b[p];\n      }\n    };\n\n    return _extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    _extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __generator = this && this.__generator || function (thisArg, body) {\n  var _ = {\n    label: 0,\n    sent: function sent() {\n      if (t[0] & 1) throw t[1];\n      return t[1];\n    },\n    trys: [],\n    ops: []\n  },\n      f,\n      y,\n      t,\n      g;\n  return g = {\n    next: verb(0),\n    \"throw\": verb(1),\n    \"return\": verb(2)\n  }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n    return this;\n  }), g;\n\n  function verb(n) {\n    return function (v) {\n      return step([n, v]);\n    };\n  }\n\n  function step(op) {\n    if (f) throw new TypeError(\"Generator is already executing.\");\n\n    while (_) {\n      try {\n        if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n        if (y = 0, t) op = [op[0] & 2, t.value];\n\n        switch (op[0]) {\n          case 0:\n          case 1:\n            t = op;\n            break;\n\n          case 4:\n            _.label++;\n            return {\n              value: op[1],\n              done: false\n            };\n\n          case 5:\n            _.label++;\n            y = op[1];\n            op = [0];\n            continue;\n\n          case 7:\n            op = _.ops.pop();\n\n            _.trys.pop();\n\n            continue;\n\n          default:\n            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n              _ = 0;\n              continue;\n            }\n\n            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n              _.label = op[1];\n              break;\n            }\n\n            if (op[0] === 6 && _.label < t[1]) {\n              _.label = t[1];\n              t = op;\n              break;\n            }\n\n            if (t && _.label < t[2]) {\n              _.label = t[2];\n\n              _.ops.push(op);\n\n              break;\n            }\n\n            if (t[2]) _.ops.pop();\n\n            _.trys.pop();\n\n            continue;\n        }\n\n        op = body.call(thisArg, _);\n      } catch (e) {\n        op = [6, e];\n        y = 0;\n      } finally {\n        f = t = 0;\n      }\n    }\n\n    if (op[0] & 5) throw op[1];\n    return {\n      value: op[0] ? op[1] : void 0,\n      done: true\n    };\n  }\n};\n\nvar __spreadArrays = this && this.__spreadArrays || function () {\n  for (var s = 0, i = 0, il = arguments.length; i < il; i++) {\n    s += arguments[i].length;\n  }\n\n  for (var r = Array(s), k = 0, i = 0; i < il; i++) {\n    for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++) {\n      r[k] = a[j];\n    }\n  }\n\n  return r;\n};\n\nvar NAMESPACE = 'demo';\nvar queueCongestion = 0;\nvar queuePending = false;\nvar scopeId;\nvar contentRef;\nvar hostTagName;\nvar useNativeShadowDom = false;\nvar checkSlotFallbackVisibility = false;\nvar checkSlotRelocate = false;\nvar isSvgMode = false;\nvar win = window;\nvar doc = document;\nvar plt = {\n  $flags$: 0,\n  $resourcesUrl$: '',\n  jmp: function jmp(h) {\n    return h();\n  },\n  raf: function raf(h) {\n    return requestAnimationFrame(h);\n  },\n  ael: function ael(el, eventName, listener, opts) {\n    return el.addEventListener(eventName, listener, opts);\n  },\n  rel: function rel(el, eventName, listener, opts) {\n    return el.removeEventListener(eventName, listener, opts);\n  }\n};\n\nvar supportsShadowDom =\n/*@__PURE__*/\nfunction () {\n  return !!doc.documentElement.attachShadow;\n}();\n\nvar supportsConstructibleStylesheets =\n/*@__PURE__*/\nfunction () {\n  try {\n    new CSSStyleSheet();\n    return true;\n  } catch (e) {}\n\n  return false;\n}();\n\nvar hostRefs = new WeakMap();\n\nvar getHostRef = function getHostRef(ref) {\n  return hostRefs.get(ref);\n};\n\nvar registerInstance = function registerInstance(lazyInstance, hostRef) {\n  return hostRefs.set(hostRef.$lazyInstance$ = lazyInstance, hostRef);\n};\n\nvar registerHost = function registerHost(elm) {\n  var hostRef = {\n    $flags$: 0,\n    $hostElement$: elm,\n    $instanceValues$: new Map()\n  };\n  {\n    hostRef.$onReadyPromise$ = new Promise(function (r) {\n      return hostRef.$onReadyResolve$ = r;\n    });\n    elm['s-p'] = [];\n    elm['s-rc'] = [];\n  }\n  return hostRefs.set(elm, hostRef);\n};\n\nvar isMemberInElement = function isMemberInElement(elm, memberName) {\n  return memberName in elm;\n};\n\nvar consoleError = function consoleError(e) {\n  return console.error(e);\n};\n\nvar moduleCache =\n/*@__PURE__*/\nnew Map();\n\nvar loadModule = function loadModule(cmpMeta, hostRef, hmrVersionId) {\n  // loadModuleImport\n  var exportName = cmpMeta.$tagName$.replace(/-/g, '_');\n  var bundleId = cmpMeta.$lazyBundleIds$;\n  var module = moduleCache.get(bundleId);\n\n  if (module) {\n    return module[exportName];\n  }\n\n  return import(\n  /* webpackInclude: /\\.entry\\.js$/ */\n\n  /* webpackExclude: /\\.system\\.entry\\.js$/ */\n\n  /* webpackMode: \"lazy\" */\n  \"./\" + bundleId + \".entry.js\" + '').then(function (importedModule) {\n    {\n      moduleCache.set(bundleId, importedModule);\n    }\n    return importedModule[exportName];\n  }, consoleError);\n};\n\nvar styles = new Map();\nvar queueDomReads = [];\nvar queueDomWrites = [];\nvar queueDomWritesLow = [];\n\nvar queueTask = function queueTask(queue, write) {\n  return function (cb) {\n    queue.push(cb);\n\n    if (!queuePending) {\n      queuePending = true;\n\n      if (write && plt.$flags$ & 4\n      /* queueSync */\n      ) {\n          nextTick(flush);\n        } else {\n        plt.raf(flush);\n      }\n    }\n  };\n};\n\nvar consume = function consume(queue) {\n  for (var i = 0; i < queue.length; i++) {\n    try {\n      queue[i](performance.now());\n    } catch (e) {\n      consoleError(e);\n    }\n  }\n\n  queue.length = 0;\n};\n\nvar consumeTimeout = function consumeTimeout(queue, timeout) {\n  var i = 0;\n  var ts = 0;\n\n  while (i < queue.length && (ts = performance.now()) < timeout) {\n    try {\n      queue[i++](ts);\n    } catch (e) {\n      consoleError(e);\n    }\n  }\n\n  if (i === queue.length) {\n    queue.length = 0;\n  } else if (i !== 0) {\n    queue.splice(0, i);\n  }\n};\n\nvar flush = function flush() {\n  queueCongestion++; // always force a bunch of medium callbacks to run, but still have\n  // a throttle on how many can run in a certain time\n  // DOM READS!!!\n\n  consume(queueDomReads);\n  var timeout = (plt.$flags$ & 6\n  /* queueMask */\n  ) === 2\n  /* appLoaded */\n  ? performance.now() + 10 * Math.ceil(queueCongestion * (1.0 / 22.0)) : Infinity; // DOM WRITES!!!\n\n  consumeTimeout(queueDomWrites, timeout);\n  consumeTimeout(queueDomWritesLow, timeout);\n\n  if (queueDomWrites.length > 0) {\n    queueDomWritesLow.push.apply(queueDomWritesLow, queueDomWrites);\n    queueDomWrites.length = 0;\n  }\n\n  if (queuePending = queueDomReads.length + queueDomWrites.length + queueDomWritesLow.length > 0) {\n    // still more to do yet, but we've run out of time\n    // let's let this thing cool off and try again in the next tick\n    plt.raf(flush);\n  } else {\n    queueCongestion = 0;\n  }\n};\n\nvar nextTick =\n/*@__PURE__*/\nfunction nextTick(cb) {\n  return Promise.resolve().then(cb);\n};\n\nvar writeTask =\n/*@__PURE__*/\nqueueTask(queueDomWrites, true);\n/**\n * Default style mode id\n */\n\n/**\n * Reusable empty obj/array\n * Don't add values to these!!\n */\n\nvar EMPTY_OBJ = {};\n\nvar isDef = function isDef(v) {\n  return v != null;\n};\n\nvar isComplexType = function isComplexType(o) {\n  // https://jsperf.com/typeof-fn-object/5\n  o = typeof o;\n  return o === 'object' || o === 'function';\n};\n\nvar getDynamicImportFunction = function getDynamicImportFunction(namespace) {\n  return \"__sc_import_\" + namespace.replace(/\\s|-/g, '_');\n};\n\nvar createTime = function createTime(fnName, tagName) {\n  if (tagName === void 0) {\n    tagName = '';\n  }\n\n  {\n    return function () {\n      return;\n    };\n  }\n};\n\nvar uniqueTime = function uniqueTime(key, measureText) {\n  {\n    return function () {\n      return;\n    };\n  }\n};\n\nvar patchEsm = function patchEsm() {\n  // @ts-ignore\n  if (!(win.CSS && win.CSS.supports && win.CSS.supports('color', 'var(--c)'))) {\n    // @ts-ignore\n    return import('./css-shim-978387b1-1e75855f.js').then(function () {\n      plt.$cssShim$ = win.__stencil_cssshim;\n\n      if (plt.$cssShim$) {\n        return plt.$cssShim$.initShim();\n      }\n    });\n  }\n\n  return Promise.resolve();\n};\n\nvar patchBrowser = function patchBrowser() {\n  return __awaiter(void 0, void 0, void 0, function () {\n    var importMeta, regex, scriptElm, opts, resourcesUrl;\n    return __generator(this, function (_a) {\n      switch (_a.label) {\n        case 0:\n          {\n            plt.$cssShim$ = win.__stencil_cssshim;\n          }\n          importMeta = \"\";\n          regex = new RegExp(\"/\" + NAMESPACE + \"(\\\\.esm)?\\\\.js($|\\\\?|#)\");\n          scriptElm = Array.from(doc.querySelectorAll('script')).find(function (s) {\n            return regex.test(s.src) || s.getAttribute('data-stencil-namespace') === NAMESPACE;\n          });\n          opts = scriptElm['data-opts'];\n          if (!(importMeta !== '')) return [3\n          /*break*/\n          , 1];\n          return [2\n          /*return*/\n          , Object.assign(Object.assign({}, opts), {\n            resourcesUrl: new URL('.', importMeta).href\n          })];\n\n        case 1:\n          resourcesUrl = new URL('.', new URL(scriptElm.getAttribute('data-resources-url') || scriptElm.src, win.location.href));\n          patchDynamicImport(resourcesUrl.href);\n          if (!!window.customElements) return [3\n          /*break*/\n          , 3]; // @ts-ignore\n\n          return [4\n          /*yield*/\n          , import('./dom-96781eef-a2fb04dd.js')];\n\n        case 2:\n          // @ts-ignore\n          _a.sent();\n\n          _a.label = 3;\n\n        case 3:\n          return [2\n          /*return*/\n          , Object.assign(Object.assign({}, opts), {\n            resourcesUrl: resourcesUrl.href\n          })];\n      }\n    });\n  });\n};\n\nvar patchDynamicImport = function patchDynamicImport(base) {\n  var importFunctionName = getDynamicImportFunction(NAMESPACE);\n\n  try {\n    // There is a caching issue in V8, that breaks using import() in Function\n    // By generating a random string, we can workaround it\n    // Check https://bugs.chromium.org/p/v8/issues/detail?id=9558 for more info\n    win[importFunctionName] = new Function('w', \"return import(w);//\" + Math.random());\n  } catch (e) {\n    var moduleMap_1 = new Map();\n\n    win[importFunctionName] = function (src) {\n      var url = new URL(src, base).href;\n      var mod = moduleMap_1.get(url);\n\n      if (!mod) {\n        var script_1 = doc.createElement('script');\n        script_1.type = 'module';\n        script_1.src = URL.createObjectURL(new Blob([\"import * as m from '\" + url + \"'; window.\" + importFunctionName + \".m = m;\"], {\n          type: 'application/javascript'\n        }));\n        mod = new Promise(function (resolve) {\n          script_1.onload = function () {\n            resolve(win[importFunctionName].m);\n            script_1.remove();\n          };\n        });\n        moduleMap_1.set(url, mod);\n        doc.head.appendChild(script_1);\n      }\n\n      return mod;\n    };\n  }\n};\n\nvar parsePropertyValue = function parsePropertyValue(propValue, propType) {\n  // ensure this value is of the correct prop type\n  if (propValue != null && !isComplexType(propValue)) {\n    if (propType & 2\n    /* Number */\n    ) {\n        // force it to be a number\n        return parseFloat(propValue);\n      }\n\n    if (propType & 1\n    /* String */\n    ) {\n        // could have been passed as a number or boolean\n        // but we still want it as a string\n        return String(propValue);\n      } // redundant return here for better minification\n\n\n    return propValue;\n  } // not sure exactly what type we want\n  // so no need to change to a different type\n\n\n  return propValue;\n};\n\nvar HYDRATED_CLASS = 'hydrated';\nvar rootAppliedStyles = new WeakMap();\n\nvar registerStyle = function registerStyle(scopeId, cssText, allowCS) {\n  var style = styles.get(scopeId);\n\n  if (supportsConstructibleStylesheets && allowCS) {\n    style = style || new CSSStyleSheet();\n    style.replace(cssText);\n  } else {\n    style = cssText;\n  }\n\n  styles.set(scopeId, style);\n};\n\nvar addStyle = function addStyle(styleContainerNode, cmpMeta, mode, hostElm) {\n  var scopeId = getScopeId(cmpMeta.$tagName$);\n  var style = styles.get(scopeId); // if an element is NOT connected then getRootNode() will return the wrong root node\n  // so the fallback is to always use the document for the root node in those cases\n\n  styleContainerNode = styleContainerNode.nodeType === 11\n  /* DocumentFragment */\n  ? styleContainerNode : doc;\n\n  if (style) {\n    if (typeof style === 'string') {\n      styleContainerNode = styleContainerNode.head || styleContainerNode;\n      var appliedStyles = rootAppliedStyles.get(styleContainerNode);\n      var styleElm = void 0;\n\n      if (!appliedStyles) {\n        rootAppliedStyles.set(styleContainerNode, appliedStyles = new Set());\n      }\n\n      if (!appliedStyles.has(scopeId)) {\n        {\n          if (plt.$cssShim$) {\n            styleElm = plt.$cssShim$.createHostStyle(hostElm, scopeId, style, !!(cmpMeta.$flags$ & 10\n            /* needsScopedEncapsulation */\n            ));\n            var newScopeId = styleElm['s-sc'];\n\n            if (newScopeId) {\n              scopeId = newScopeId; // we don't want to add this styleID to the appliedStyles Set\n              // since the cssVarShim might need to apply several different\n              // stylesheets for the same component\n\n              appliedStyles = null;\n            }\n          } else {\n            styleElm = doc.createElement('style');\n            styleElm.innerHTML = style;\n          }\n\n          styleContainerNode.insertBefore(styleElm, styleContainerNode.querySelector('link'));\n        }\n\n        if (appliedStyles) {\n          appliedStyles.add(scopeId);\n        }\n      }\n    } else if (!styleContainerNode.adoptedStyleSheets.includes(style)) {\n      styleContainerNode.adoptedStyleSheets = __spreadArrays(styleContainerNode.adoptedStyleSheets, [style]);\n    }\n  }\n\n  return scopeId;\n};\n\nvar attachStyles = function attachStyles(elm, cmpMeta, mode) {\n  var endAttachStyles = createTime('attachStyles', cmpMeta.$tagName$);\n  var scopeId = addStyle(supportsShadowDom && elm.shadowRoot ? elm.shadowRoot : elm.getRootNode(), cmpMeta, mode, elm);\n\n  if (cmpMeta.$flags$ & 10\n  /* needsScopedEncapsulation */\n  ) {\n      // only required when we're NOT using native shadow dom (slot)\n      // or this browser doesn't support native shadow dom\n      // and this host element was NOT created with SSR\n      // let's pick out the inner content for slot projection\n      // create a node to represent where the original\n      // content was first placed, which is useful later on\n      // DOM WRITE!!\n      elm['s-sc'] = scopeId;\n      elm.classList.add(scopeId + '-h');\n    }\n\n  endAttachStyles();\n};\n\nvar getScopeId = function getScopeId(tagName, mode) {\n  return 'sc-' + tagName;\n};\n/**\n * Production h() function based on Preact by\n * Jason Miller (@developit)\n * Licensed under the MIT License\n * https://github.com/developit/preact/blob/master/LICENSE\n *\n * Modified for Stencil's compiler and vdom\n */\n// const stack: any[] = [];\n// export function h(nodeName: string | d.FunctionalComponent, vnodeData: d.PropsType, child?: d.ChildType): d.VNode;\n// export function h(nodeName: string | d.FunctionalComponent, vnodeData: d.PropsType, ...children: d.ChildType[]): d.VNode;\n\n\nvar h = function h(nodeName, vnodeData) {\n  var children = [];\n\n  for (var _i = 2; _i < arguments.length; _i++) {\n    children[_i - 2] = arguments[_i];\n  }\n\n  var child = null;\n  var slotName = null;\n  var simple = false;\n  var lastSimple = false;\n  var vNodeChildren = [];\n\n  var walk = function walk(c) {\n    for (var i = 0; i < c.length; i++) {\n      child = c[i];\n\n      if (Array.isArray(child)) {\n        walk(child);\n      } else if (child != null && typeof child !== 'boolean') {\n        if (simple = typeof nodeName !== 'function' && !isComplexType(child)) {\n          child = String(child);\n        }\n\n        if (simple && lastSimple) {\n          // If the previous child was simple (string), we merge both\n          vNodeChildren[vNodeChildren.length - 1].$text$ += child;\n        } else {\n          // Append a new vNode, if it's text, we create a text vNode\n          vNodeChildren.push(simple ? newVNode(null, child) : child);\n        }\n\n        lastSimple = simple;\n      }\n    }\n  };\n\n  walk(children);\n\n  if (vnodeData) {\n    if (vnodeData.name) {\n      slotName = vnodeData.name;\n    }\n\n    {\n      var classData_1 = vnodeData.className || vnodeData.class;\n\n      if (classData_1) {\n        vnodeData.class = typeof classData_1 !== 'object' ? classData_1 : Object.keys(classData_1).filter(function (k) {\n          return classData_1[k];\n        }).join(' ');\n      }\n    }\n  }\n\n  var vnode = newVNode(nodeName, null);\n  vnode.$attrs$ = vnodeData;\n\n  if (vNodeChildren.length > 0) {\n    vnode.$children$ = vNodeChildren;\n  }\n\n  {\n    vnode.$name$ = slotName;\n  }\n  return vnode;\n};\n\nvar newVNode = function newVNode(tag, text) {\n  var vnode = {\n    $flags$: 0,\n    $tag$: tag,\n    $text$: text,\n    $elm$: null,\n    $children$: null\n  };\n  {\n    vnode.$attrs$ = null;\n  }\n  {\n    vnode.$name$ = null;\n  }\n  return vnode;\n};\n\nvar Host = {};\n\nvar isHost = function isHost(node) {\n  return node && node.$tag$ === Host;\n};\n/**\n * Production setAccessor() function based on Preact by\n * Jason Miller (@developit)\n * Licensed under the MIT License\n * https://github.com/developit/preact/blob/master/LICENSE\n *\n * Modified for Stencil's compiler and vdom\n */\n\n\nvar setAccessor = function setAccessor(elm, memberName, oldValue, newValue, isSvg, flags) {\n  if (oldValue === newValue) {\n    return;\n  }\n\n  var isProp = isMemberInElement(elm, memberName);\n  var ln = memberName.toLowerCase();\n\n  if (memberName === 'class') {\n    var classList = elm.classList;\n    var oldClasses_1 = parseClassList(oldValue);\n    var newClasses_1 = parseClassList(newValue);\n    classList.remove.apply(classList, oldClasses_1.filter(function (c) {\n      return c && !newClasses_1.includes(c);\n    }));\n    classList.add.apply(classList, newClasses_1.filter(function (c) {\n      return c && !oldClasses_1.includes(c);\n    }));\n  } else if (memberName === 'ref') {\n    // minifier will clean this up\n    if (newValue) {\n      newValue(elm);\n    }\n  } else if (!isProp && memberName[0] === 'o' && memberName[1] === 'n') {\n    // Event Handlers\n    // so if the member name starts with \"on\" and the 3rd characters is\n    // a capital letter, and it's not already a member on the element,\n    // then we're assuming it's an event listener\n    if (memberName[2] === '-') {\n      // on- prefixed events\n      // allows to be explicit about the dom event to listen without any magic\n      // under the hood:\n      // <my-cmp on-click> // listens for \"click\"\n      // <my-cmp on-Click> // listens for \"Click\"\n      // <my-cmp on-ionChange> // listens for \"ionChange\"\n      // <my-cmp on-EVENTS> // listens for \"EVENTS\"\n      memberName = memberName.slice(3);\n    } else if (isMemberInElement(win, ln)) {\n      // standard event\n      // the JSX attribute could have been \"onMouseOver\" and the\n      // member name \"onmouseover\" is on the window's prototype\n      // so let's add the listener \"mouseover\", which is all lowercased\n      memberName = ln.slice(2);\n    } else {\n      // custom event\n      // the JSX attribute could have been \"onMyCustomEvent\"\n      // so let's trim off the \"on\" prefix and lowercase the first character\n      // and add the listener \"myCustomEvent\"\n      // except for the first character, we keep the event name case\n      memberName = ln[2] + memberName.slice(3);\n    }\n\n    if (oldValue) {\n      plt.rel(elm, memberName, oldValue, false);\n    }\n\n    if (newValue) {\n      plt.ael(elm, memberName, newValue, false);\n    }\n  } else {\n    // Set property if it exists and it's not a SVG\n    var isComplex = isComplexType(newValue);\n\n    if ((isProp || isComplex && newValue !== null) && !isSvg) {\n      try {\n        if (!elm.tagName.includes('-')) {\n          var n = newValue == null ? '' : newValue; // Workaround for Safari, moving the <input> caret when re-assigning the same valued\n\n          if (memberName === 'list') {\n            isProp = false; // tslint:disable-next-line: triple-equals\n          } else if (oldValue == null || elm[memberName] != n) {\n            elm[memberName] = n;\n          }\n        } else {\n          elm[memberName] = newValue;\n        }\n      } catch (e) {}\n    }\n\n    if (newValue == null || newValue === false) {\n      {\n        elm.removeAttribute(memberName);\n      }\n    } else if ((!isProp || flags & 4\n    /* isHost */\n    || isSvg) && !isComplex) {\n      newValue = newValue === true ? '' : newValue;\n      {\n        elm.setAttribute(memberName, newValue);\n      }\n    }\n  }\n};\n\nvar parseClassListRegex = /\\s/;\n\nvar parseClassList = function parseClassList(value) {\n  return !value ? [] : value.split(parseClassListRegex);\n};\n\nvar updateElement = function updateElement(oldVnode, newVnode, isSvgMode, memberName) {\n  // if the element passed in is a shadow root, which is a document fragment\n  // then we want to be adding attrs/props to the shadow root's \"host\" element\n  // if it's not a shadow root, then we add attrs/props to the same element\n  var elm = newVnode.$elm$.nodeType === 11\n  /* DocumentFragment */\n  && newVnode.$elm$.host ? newVnode.$elm$.host : newVnode.$elm$;\n  var oldVnodeAttrs = oldVnode && oldVnode.$attrs$ || EMPTY_OBJ;\n  var newVnodeAttrs = newVnode.$attrs$ || EMPTY_OBJ;\n  {\n    // remove attributes no longer present on the vnode by setting them to undefined\n    for (memberName in oldVnodeAttrs) {\n      if (!(memberName in newVnodeAttrs)) {\n        setAccessor(elm, memberName, oldVnodeAttrs[memberName], undefined, isSvgMode, newVnode.$flags$);\n      }\n    }\n  } // add new & update changed attributes\n\n  for (memberName in newVnodeAttrs) {\n    setAccessor(elm, memberName, oldVnodeAttrs[memberName], newVnodeAttrs[memberName], isSvgMode, newVnode.$flags$);\n  }\n};\n\nvar createElm = function createElm(oldParentVNode, newParentVNode, childIndex, parentElm) {\n  // tslint:disable-next-line: prefer-const\n  var newVNode = newParentVNode.$children$[childIndex];\n  var i = 0;\n  var elm;\n  var childNode;\n  var oldVNode;\n\n  if (!useNativeShadowDom) {\n    // remember for later we need to check to relocate nodes\n    checkSlotRelocate = true;\n\n    if (newVNode.$tag$ === 'slot') {\n      if (scopeId) {\n        // scoped css needs to add its scoped id to the parent element\n        parentElm.classList.add(scopeId + '-s');\n      }\n\n      newVNode.$flags$ |= newVNode.$children$ ? // slot element has fallback content\n      // still create an element that \"mocks\" the slot element\n      2\n      /* isSlotFallback */\n      // slot element does not have fallback content\n      // create an html comment we'll use to always reference\n      // where actual slot content should sit next to\n      : 1\n      /* isSlotReference */\n      ;\n    }\n  }\n\n  if (newVNode.$text$ !== null) {\n    // create text node\n    elm = newVNode.$elm$ = doc.createTextNode(newVNode.$text$);\n  } else if (newVNode.$flags$ & 1\n  /* isSlotReference */\n  ) {\n      // create a slot reference node\n      elm = newVNode.$elm$ = doc.createTextNode('');\n    } else {\n    // create element\n    elm = newVNode.$elm$ = doc.createElement(newVNode.$flags$ & 2\n    /* isSlotFallback */\n    ? 'slot-fb' : newVNode.$tag$); // add css classes, attrs, props, listeners, etc.\n\n    {\n      updateElement(null, newVNode, isSvgMode);\n    }\n\n    if (isDef(scopeId) && elm['s-si'] !== scopeId) {\n      // if there is a scopeId and this is the initial render\n      // then let's add the scopeId as a css class\n      elm.classList.add(elm['s-si'] = scopeId);\n    }\n\n    if (newVNode.$children$) {\n      for (i = 0; i < newVNode.$children$.length; ++i) {\n        // create the node\n        childNode = createElm(oldParentVNode, newVNode, i, elm); // return node could have been null\n\n        if (childNode) {\n          // append our new node\n          elm.appendChild(childNode);\n        }\n      }\n    }\n  }\n\n  {\n    elm['s-hn'] = hostTagName;\n\n    if (newVNode.$flags$ & (2\n    /* isSlotFallback */\n    | 1\n    /* isSlotReference */\n    )) {\n      // remember the content reference comment\n      elm['s-sr'] = true; // remember the content reference comment\n\n      elm['s-cr'] = contentRef; // remember the slot name, or empty string for default slot\n\n      elm['s-sn'] = newVNode.$name$ || ''; // check if we've got an old vnode for this slot\n\n      oldVNode = oldParentVNode && oldParentVNode.$children$ && oldParentVNode.$children$[childIndex];\n\n      if (oldVNode && oldVNode.$tag$ === newVNode.$tag$ && oldParentVNode.$elm$) {\n        // we've got an old slot vnode and the wrapper is being replaced\n        // so let's move the old slot content back to it's original location\n        putBackInOriginalLocation(oldParentVNode.$elm$, false);\n      }\n    }\n  }\n  return elm;\n};\n\nvar putBackInOriginalLocation = function putBackInOriginalLocation(parentElm, recursive) {\n  plt.$flags$ |= 1\n  /* isTmpDisconnected */\n  ;\n  var oldSlotChildNodes = parentElm.childNodes;\n\n  for (var i = oldSlotChildNodes.length - 1; i >= 0; i--) {\n    var childNode = oldSlotChildNodes[i];\n\n    if (childNode['s-hn'] !== hostTagName && childNode['s-ol']) {\n      // // this child node in the old element is from another component\n      // // remove this node from the old slot's parent\n      // childNode.remove();\n      // and relocate it back to it's original location\n      parentReferenceNode(childNode).insertBefore(childNode, referenceNode(childNode)); // remove the old original location comment entirely\n      // later on the patch function will know what to do\n      // and move this to the correct spot in need be\n\n      childNode['s-ol'].remove();\n      childNode['s-ol'] = undefined;\n      checkSlotRelocate = true;\n    }\n\n    if (recursive) {\n      putBackInOriginalLocation(childNode, recursive);\n    }\n  }\n\n  plt.$flags$ &= ~1\n  /* isTmpDisconnected */\n  ;\n};\n\nvar addVnodes = function addVnodes(parentElm, before, parentVNode, vnodes, startIdx, endIdx) {\n  var containerElm = parentElm['s-cr'] && parentElm['s-cr'].parentNode || parentElm;\n  var childNode;\n\n  if (containerElm.shadowRoot && containerElm.tagName === hostTagName) {\n    containerElm = containerElm.shadowRoot;\n  }\n\n  for (; startIdx <= endIdx; ++startIdx) {\n    if (vnodes[startIdx]) {\n      childNode = createElm(null, parentVNode, startIdx, parentElm);\n\n      if (childNode) {\n        vnodes[startIdx].$elm$ = childNode;\n        containerElm.insertBefore(childNode, referenceNode(before));\n      }\n    }\n  }\n};\n\nvar removeVnodes = function removeVnodes(vnodes, startIdx, endIdx, vnode, elm) {\n  for (; startIdx <= endIdx; ++startIdx) {\n    if (vnode = vnodes[startIdx]) {\n      elm = vnode.$elm$;\n      callNodeRefs(vnode);\n      {\n        // we're removing this element\n        // so it's possible we need to show slot fallback content now\n        checkSlotFallbackVisibility = true;\n\n        if (elm['s-ol']) {\n          // remove the original location comment\n          elm['s-ol'].remove();\n        } else {\n          // it's possible that child nodes of the node\n          // that's being removed are slot nodes\n          putBackInOriginalLocation(elm, true);\n        }\n      } // remove the vnode's element from the dom\n\n      elm.remove();\n    }\n  }\n};\n\nvar updateChildren = function updateChildren(parentElm, oldCh, newVNode, newCh) {\n  var oldStartIdx = 0;\n  var newStartIdx = 0;\n  var oldEndIdx = oldCh.length - 1;\n  var oldStartVnode = oldCh[0];\n  var oldEndVnode = oldCh[oldEndIdx];\n  var newEndIdx = newCh.length - 1;\n  var newStartVnode = newCh[0];\n  var newEndVnode = newCh[newEndIdx];\n  var node;\n\n  while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {\n    if (oldStartVnode == null) {\n      // Vnode might have been moved left\n      oldStartVnode = oldCh[++oldStartIdx];\n    } else if (oldEndVnode == null) {\n      oldEndVnode = oldCh[--oldEndIdx];\n    } else if (newStartVnode == null) {\n      newStartVnode = newCh[++newStartIdx];\n    } else if (newEndVnode == null) {\n      newEndVnode = newCh[--newEndIdx];\n    } else if (isSameVnode(oldStartVnode, newStartVnode)) {\n      patch(oldStartVnode, newStartVnode);\n      oldStartVnode = oldCh[++oldStartIdx];\n      newStartVnode = newCh[++newStartIdx];\n    } else if (isSameVnode(oldEndVnode, newEndVnode)) {\n      patch(oldEndVnode, newEndVnode);\n      oldEndVnode = oldCh[--oldEndIdx];\n      newEndVnode = newCh[--newEndIdx];\n    } else if (isSameVnode(oldStartVnode, newEndVnode)) {\n      // Vnode moved right\n      if (oldStartVnode.$tag$ === 'slot' || newEndVnode.$tag$ === 'slot') {\n        putBackInOriginalLocation(oldStartVnode.$elm$.parentNode, false);\n      }\n\n      patch(oldStartVnode, newEndVnode);\n      parentElm.insertBefore(oldStartVnode.$elm$, oldEndVnode.$elm$.nextSibling);\n      oldStartVnode = oldCh[++oldStartIdx];\n      newEndVnode = newCh[--newEndIdx];\n    } else if (isSameVnode(oldEndVnode, newStartVnode)) {\n      // Vnode moved left\n      if (oldStartVnode.$tag$ === 'slot' || newEndVnode.$tag$ === 'slot') {\n        putBackInOriginalLocation(oldEndVnode.$elm$.parentNode, false);\n      }\n\n      patch(oldEndVnode, newStartVnode);\n      parentElm.insertBefore(oldEndVnode.$elm$, oldStartVnode.$elm$);\n      oldEndVnode = oldCh[--oldEndIdx];\n      newStartVnode = newCh[++newStartIdx];\n    } else {\n      {\n        // new element\n        node = createElm(oldCh && oldCh[newStartIdx], newVNode, newStartIdx, parentElm);\n        newStartVnode = newCh[++newStartIdx];\n      }\n\n      if (node) {\n        {\n          parentReferenceNode(oldStartVnode.$elm$).insertBefore(node, referenceNode(oldStartVnode.$elm$));\n        }\n      }\n    }\n  }\n\n  if (oldStartIdx > oldEndIdx) {\n    addVnodes(parentElm, newCh[newEndIdx + 1] == null ? null : newCh[newEndIdx + 1].$elm$, newVNode, newCh, newStartIdx, newEndIdx);\n  } else if (newStartIdx > newEndIdx) {\n    removeVnodes(oldCh, oldStartIdx, oldEndIdx);\n  }\n};\n\nvar isSameVnode = function isSameVnode(vnode1, vnode2) {\n  // compare if two vnode to see if they're \"technically\" the same\n  // need to have the same element tag, and same key to be the same\n  if (vnode1.$tag$ === vnode2.$tag$) {\n    if (vnode1.$tag$ === 'slot') {\n      return vnode1.$name$ === vnode2.$name$;\n    }\n\n    return true;\n  }\n\n  return false;\n};\n\nvar referenceNode = function referenceNode(node) {\n  // this node was relocated to a new location in the dom\n  // because of some other component's slot\n  // but we still have an html comment in place of where\n  // it's original location was according to it's original vdom\n  return node && node['s-ol'] || node;\n};\n\nvar parentReferenceNode = function parentReferenceNode(node) {\n  return (node['s-ol'] ? node['s-ol'] : node).parentNode;\n};\n\nvar patch = function patch(oldVNode, newVNode) {\n  var elm = newVNode.$elm$ = oldVNode.$elm$;\n  var oldChildren = oldVNode.$children$;\n  var newChildren = newVNode.$children$;\n  var defaultHolder;\n\n  if (newVNode.$text$ === null) {\n    // element node\n    {\n      if (newVNode.$tag$ === 'slot') ;else {\n        // either this is the first render of an element OR it's an update\n        // AND we already know it's possible it could have changed\n        // this updates the element's css classes, attrs, props, listeners, etc.\n        updateElement(oldVNode, newVNode, isSvgMode);\n      }\n    }\n\n    if (oldChildren !== null && newChildren !== null) {\n      // looks like there's child vnodes for both the old and new vnodes\n      updateChildren(elm, oldChildren, newVNode, newChildren);\n    } else if (newChildren !== null) {\n      // no old child vnodes, but there are new child vnodes to add\n      if (oldVNode.$text$ !== null) {\n        // the old vnode was text, so be sure to clear it out\n        elm.textContent = '';\n      } // add the new vnode children\n\n\n      addVnodes(elm, null, newVNode, newChildren, 0, newChildren.length - 1);\n    } else if (oldChildren !== null) {\n      // no new child vnodes, but there are old child vnodes to remove\n      removeVnodes(oldChildren, 0, oldChildren.length - 1);\n    }\n  } else if (defaultHolder = elm['s-cr']) {\n    // this element has slotted content\n    defaultHolder.parentNode.textContent = newVNode.$text$;\n  } else if (oldVNode.$text$ !== newVNode.$text$) {\n    // update the text content for the text only vnode\n    // and also only if the text is different than before\n    elm.data = newVNode.$text$;\n  }\n};\n\nvar updateFallbackSlotVisibility = function updateFallbackSlotVisibility(elm) {\n  // tslint:disable-next-line: prefer-const\n  var childNodes = elm.childNodes;\n  var childNode;\n  var i;\n  var ilen;\n  var j;\n  var slotNameAttr;\n  var nodeType;\n\n  for (i = 0, ilen = childNodes.length; i < ilen; i++) {\n    childNode = childNodes[i];\n\n    if (childNode.nodeType === 1\n    /* ElementNode */\n    ) {\n        if (childNode['s-sr']) {\n          // this is a slot fallback node\n          // get the slot name for this slot reference node\n          slotNameAttr = childNode['s-sn']; // by default always show a fallback slot node\n          // then hide it if there are other slots in the light dom\n\n          childNode.hidden = false;\n\n          for (j = 0; j < ilen; j++) {\n            if (childNodes[j]['s-hn'] !== childNode['s-hn']) {\n              // this sibling node is from a different component\n              nodeType = childNodes[j].nodeType;\n\n              if (slotNameAttr !== '') {\n                // this is a named fallback slot node\n                if (nodeType === 1\n                /* ElementNode */\n                && slotNameAttr === childNodes[j].getAttribute('slot')) {\n                  childNode.hidden = true;\n                  break;\n                }\n              } else {\n                // this is a default fallback slot node\n                // any element or text node (with content)\n                // should hide the default fallback slot node\n                if (nodeType === 1\n                /* ElementNode */\n                || nodeType === 3\n                /* TextNode */\n                && childNodes[j].textContent.trim() !== '') {\n                  childNode.hidden = true;\n                  break;\n                }\n              }\n            }\n          }\n        } // keep drilling down\n\n\n        updateFallbackSlotVisibility(childNode);\n      }\n  }\n};\n\nvar relocateNodes = [];\n\nvar relocateSlotContent = function relocateSlotContent(elm) {\n  // tslint:disable-next-line: prefer-const\n  var childNodes = elm.childNodes;\n  var ilen = childNodes.length;\n  var i = 0;\n  var j = 0;\n  var nodeType = 0;\n  var childNode;\n  var node;\n  var hostContentNodes;\n  var slotNameAttr;\n\n  for (ilen = childNodes.length; i < ilen; i++) {\n    childNode = childNodes[i];\n\n    if (childNode['s-sr'] && (node = childNode['s-cr'])) {\n      // first got the content reference comment node\n      // then we got it's parent, which is where all the host content is in now\n      hostContentNodes = node.parentNode.childNodes;\n      slotNameAttr = childNode['s-sn'];\n\n      for (j = hostContentNodes.length - 1; j >= 0; j--) {\n        node = hostContentNodes[j];\n\n        if (!node['s-cn'] && !node['s-nr'] && node['s-hn'] !== childNode['s-hn']) {\n          // let's do some relocating to its new home\n          // but never relocate a content reference node\n          // that is suppose to always represent the original content location\n          nodeType = node.nodeType;\n\n          if ((nodeType === 3\n          /* TextNode */\n          || nodeType === 8\n          /* CommentNode */\n          ) && slotNameAttr === '' || nodeType === 1\n          /* ElementNode */\n          && node.getAttribute('slot') === null && slotNameAttr === '' || nodeType === 1\n          /* ElementNode */\n          && node.getAttribute('slot') === slotNameAttr) {\n            // it's possible we've already decided to relocate this node\n            if (!relocateNodes.some(function (r) {\n              return r.$nodeToRelocate$ === node;\n            })) {\n              // made some changes to slots\n              // let's make sure we also double check\n              // fallbacks are correctly hidden or shown\n              checkSlotFallbackVisibility = true;\n              node['s-sn'] = slotNameAttr; // add to our list of nodes to relocate\n\n              relocateNodes.push({\n                $slotRefNode$: childNode,\n                $nodeToRelocate$: node\n              });\n            }\n          }\n        }\n      }\n    }\n\n    if (childNode.nodeType === 1\n    /* ElementNode */\n    ) {\n        relocateSlotContent(childNode);\n      }\n  }\n};\n\nvar callNodeRefs = function callNodeRefs(vNode) {\n  {\n    vNode.$attrs$ && vNode.$attrs$.ref && vNode.$attrs$.ref(null);\n    vNode.$children$ && vNode.$children$.forEach(callNodeRefs);\n  }\n};\n\nvar renderVdom = function renderVdom(hostElm, hostRef, cmpMeta, renderFnResults) {\n  hostTagName = hostElm.tagName;\n  var oldVNode = hostRef.$vnode$ || newVNode(null, null);\n  var rootVnode = isHost(renderFnResults) ? renderFnResults : h(null, null, renderFnResults);\n  rootVnode.$tag$ = null;\n  rootVnode.$flags$ |= 4\n  /* isHost */\n  ;\n  hostRef.$vnode$ = rootVnode;\n  rootVnode.$elm$ = oldVNode.$elm$ = hostElm.shadowRoot || hostElm;\n  {\n    scopeId = hostElm['s-sc'];\n  }\n  {\n    contentRef = hostElm['s-cr'];\n    useNativeShadowDom = supportsShadowDom && (cmpMeta.$flags$ & 1\n    /* shadowDomEncapsulation */\n    ) !== 0; // always reset\n\n    checkSlotRelocate = checkSlotFallbackVisibility = false;\n  } // synchronous patch\n\n  patch(oldVNode, rootVnode);\n  {\n    if (checkSlotRelocate) {\n      relocateSlotContent(rootVnode.$elm$);\n\n      for (var i = 0; i < relocateNodes.length; i++) {\n        var relocateNode = relocateNodes[i];\n\n        if (!relocateNode.$nodeToRelocate$['s-ol']) {\n          // add a reference node marking this node's original location\n          // keep a reference to this node for later lookups\n          var orgLocationNode = doc.createTextNode('');\n          orgLocationNode['s-nr'] = relocateNode.$nodeToRelocate$;\n          relocateNode.$nodeToRelocate$.parentNode.insertBefore(relocateNode.$nodeToRelocate$['s-ol'] = orgLocationNode, relocateNode.$nodeToRelocate$);\n        }\n      } // while we're moving nodes around existing nodes, temporarily disable\n      // the disconnectCallback from working\n\n\n      plt.$flags$ |= 1\n      /* isTmpDisconnected */\n      ;\n\n      for (var i = 0; i < relocateNodes.length; i++) {\n        var relocateNode = relocateNodes[i]; // by default we're just going to insert it directly\n        // after the slot reference node\n\n        var parentNodeRef = relocateNode.$slotRefNode$.parentNode;\n        var insertBeforeNode = relocateNode.$slotRefNode$.nextSibling;\n        var orgLocationNode = relocateNode.$nodeToRelocate$['s-ol'];\n\n        while (orgLocationNode = orgLocationNode.previousSibling) {\n          var refNode = orgLocationNode['s-nr'];\n\n          if (refNode && refNode['s-sn'] === relocateNode.$nodeToRelocate$['s-sn'] && parentNodeRef === refNode.parentNode) {\n            refNode = refNode.nextSibling;\n\n            if (!refNode || !refNode['s-nr']) {\n              insertBeforeNode = refNode;\n              break;\n            }\n          }\n        }\n\n        if (!insertBeforeNode && parentNodeRef !== relocateNode.$nodeToRelocate$.parentNode || relocateNode.$nodeToRelocate$.nextSibling !== insertBeforeNode) {\n          // we've checked that it's worth while to relocate\n          // since that the node to relocate\n          // has a different next sibling or parent relocated\n          if (relocateNode.$nodeToRelocate$ !== insertBeforeNode) {\n            // add it back to the dom but in its new home\n            parentNodeRef.insertBefore(relocateNode.$nodeToRelocate$, insertBeforeNode);\n          }\n        }\n      } // done moving nodes around\n      // allow the disconnect callback to work again\n\n\n      plt.$flags$ &= ~1\n      /* isTmpDisconnected */\n      ;\n    }\n\n    if (checkSlotFallbackVisibility) {\n      updateFallbackSlotVisibility(rootVnode.$elm$);\n    } // always reset\n\n\n    relocateNodes.length = 0;\n  }\n};\n\nvar attachToAncestor = function attachToAncestor(hostRef, ancestorComponent) {\n  if (ancestorComponent && !hostRef.$onRenderResolve$) {\n    ancestorComponent['s-p'].push(new Promise(function (r) {\n      return hostRef.$onRenderResolve$ = r;\n    }));\n  }\n};\n\nvar scheduleUpdate = function scheduleUpdate(elm, hostRef, cmpMeta, isInitialLoad) {\n  {\n    hostRef.$flags$ |= 16\n    /* isQueuedForUpdate */\n    ;\n  }\n\n  if (hostRef.$flags$ & 4\n  /* isWaitingForChildren */\n  ) {\n      hostRef.$flags$ |= 512\n      /* needsRerender */\n      ;\n      return;\n    }\n\n  var endSchedule = createTime('scheduleUpdate', cmpMeta.$tagName$);\n  var ancestorComponent = hostRef.$ancestorComponent$;\n  var instance = hostRef.$lazyInstance$;\n\n  var update = function update() {\n    return updateComponent(elm, hostRef, cmpMeta, instance, isInitialLoad);\n  };\n\n  attachToAncestor(hostRef, ancestorComponent);\n  var promise;\n  endSchedule(); // there is no ancestorc omponent or the ancestor component\n  // has already fired off its lifecycle update then\n  // fire off the initial update\n\n  return then(promise, function () {\n    return writeTask(update);\n  });\n};\n\nvar updateComponent = function updateComponent(elm, hostRef, cmpMeta, instance, isInitialLoad) {\n  // updateComponent\n  var endUpdate = createTime('update', cmpMeta.$tagName$);\n  var rc = elm['s-rc'];\n\n  if (isInitialLoad) {\n    // DOM WRITE!\n    attachStyles(elm, cmpMeta, hostRef.$modeName$);\n  }\n\n  var endRender = createTime('render', cmpMeta.$tagName$);\n  {\n    {\n      try {\n        // looks like we've got child nodes to render into this host element\n        // or we need to update the css class/attrs on the host element\n        // DOM WRITE!\n        renderVdom(elm, hostRef, cmpMeta, instance.render());\n      } catch (e) {\n        consoleError(e);\n      }\n    }\n  }\n\n  if (plt.$cssShim$) {\n    plt.$cssShim$.updateHost(elm);\n  }\n\n  {\n    hostRef.$flags$ &= ~16\n    /* isQueuedForUpdate */\n    ;\n  }\n  {\n    hostRef.$flags$ |= 2\n    /* hasRendered */\n    ;\n  }\n\n  if (rc) {\n    // ok, so turns out there are some child host elements\n    // waiting on this parent element to load\n    // let's fire off all update callbacks waiting\n    rc.forEach(function (cb) {\n      return cb();\n    });\n    elm['s-rc'] = undefined;\n  }\n\n  endRender();\n  endUpdate();\n  {\n    var childrenPromises = elm['s-p'];\n\n    var postUpdate = function postUpdate() {\n      return postUpdateComponent(elm, hostRef, cmpMeta);\n    };\n\n    if (childrenPromises.length === 0) {\n      postUpdate();\n    } else {\n      Promise.all(childrenPromises).then(postUpdate);\n      hostRef.$flags$ |= 4\n      /* isWaitingForChildren */\n      ;\n      childrenPromises.length = 0;\n    }\n  }\n};\n\nvar postUpdateComponent = function postUpdateComponent(elm, hostRef, cmpMeta) {\n  var endPostUpdate = createTime('postUpdate', cmpMeta.$tagName$);\n  var ancestorComponent = hostRef.$ancestorComponent$;\n\n  if (!(hostRef.$flags$ & 64\n  /* hasLoadedComponent */\n  )) {\n    hostRef.$flags$ |= 64\n    /* hasLoadedComponent */\n    ;\n    {\n      // DOM WRITE!\n      // add the css class that this element has officially hydrated\n      elm.classList.add(HYDRATED_CLASS);\n    }\n    endPostUpdate();\n    {\n      hostRef.$onReadyResolve$(elm);\n\n      if (!ancestorComponent) {\n        appDidLoad();\n      }\n    }\n  } else {\n    endPostUpdate();\n  } // load events fire from bottom to top\n  // the deepest elements load first then bubbles up\n\n\n  {\n    if (hostRef.$onRenderResolve$) {\n      hostRef.$onRenderResolve$();\n      hostRef.$onRenderResolve$ = undefined;\n    }\n\n    if (hostRef.$flags$ & 512\n    /* needsRerender */\n    ) {\n        nextTick(function () {\n          return scheduleUpdate(elm, hostRef, cmpMeta, false);\n        });\n      }\n\n    hostRef.$flags$ &= ~(4\n    /* isWaitingForChildren */\n    | 512\n    /* needsRerender */\n    );\n  } // ( •_•)\n  // ( •_•)>⌐■-■\n  // (⌐■_■)\n};\n\nvar forceUpdate = function forceUpdate(elm, cmpMeta) {\n  {\n    var hostRef = getHostRef(elm);\n\n    if ((hostRef.$flags$ & (2\n    /* hasRendered */\n    | 16\n    /* isQueuedForUpdate */\n    )) === 2\n    /* hasRendered */\n    ) {\n        scheduleUpdate(elm, hostRef, cmpMeta, false);\n      }\n  }\n};\n\nvar appDidLoad = function appDidLoad(who) {\n  // on appload\n  // we have finish the first big initial render\n  {\n    doc.documentElement.classList.add(HYDRATED_CLASS);\n  }\n  {\n    plt.$flags$ |= 2\n    /* appLoaded */\n    ;\n  }\n};\n\nvar then = function then(promise, thenFn) {\n  return promise && promise.then ? promise.then(thenFn) : thenFn();\n};\n\nvar getValue = function getValue(ref, propName) {\n  return getHostRef(ref).$instanceValues$.get(propName);\n};\n\nvar setValue = function setValue(ref, propName, newVal, cmpMeta) {\n  // check our new property value against our internal value\n  var hostRef = getHostRef(ref);\n  var elm = hostRef.$hostElement$;\n  var oldVal = hostRef.$instanceValues$.get(propName);\n  var flags = hostRef.$flags$;\n  var instance = hostRef.$lazyInstance$;\n  newVal = parsePropertyValue(newVal, cmpMeta.$members$[propName][0]);\n\n  if (newVal !== oldVal && (!(flags & 8\n  /* isConstructingInstance */\n  ) || oldVal === undefined)) {\n    // gadzooks! the property's value has changed!!\n    // set our new value!\n    hostRef.$instanceValues$.set(propName, newVal);\n\n    if (instance) {\n      if ((flags & (2\n      /* hasRendered */\n      | 16\n      /* isQueuedForUpdate */\n      )) === 2\n      /* hasRendered */\n      ) {\n          // looks like this value actually changed, so we've got work to do!\n          // but only if we've already rendered, otherwise just chill out\n          // queue that we need to do an update, but don't worry about queuing\n          // up millions cuz this function ensures it only runs once\n          scheduleUpdate(elm, hostRef, cmpMeta, false);\n        }\n    }\n  }\n};\n\nvar proxyComponent = function proxyComponent(Cstr, cmpMeta, flags) {\n  if (cmpMeta.$members$) {\n    // It's better to have a const than two Object.entries()\n    var members = Object.entries(cmpMeta.$members$);\n    var prototype_1 = Cstr.prototype;\n    members.forEach(function (_a) {\n      var memberName = _a[0],\n          memberFlags = _a[1][0];\n\n      if (memberFlags & 31\n      /* Prop */\n      || flags & 2\n      /* proxyState */\n      && memberFlags & 32\n      /* State */\n      ) {\n        // proxyComponent - prop\n        Object.defineProperty(prototype_1, memberName, {\n          get: function get() {\n            // proxyComponent, get value\n            return getValue(this, memberName);\n          },\n          set: function set(newValue) {\n            // proxyComponent, set value\n            setValue(this, memberName, newValue, cmpMeta);\n          },\n          configurable: true,\n          enumerable: true\n        });\n      }\n    });\n\n    if (flags & 1\n    /* isElementConstructor */\n    ) {\n        var attrNameToPropName_1 = new Map();\n\n        prototype_1.attributeChangedCallback = function (attrName, _oldValue, newValue) {\n          var _this = this;\n\n          plt.jmp(function () {\n            var propName = attrNameToPropName_1.get(attrName);\n            _this[propName] = newValue === null && typeof _this[propName] === 'boolean' ? false : newValue;\n          });\n        }; // create an array of attributes to observe\n        // and also create a map of html attribute name to js property name\n\n\n        Cstr.observedAttributes = members.filter(function (_a) {\n          var _ = _a[0],\n              m = _a[1];\n          return m[0] & 15;\n        }\n        /* HasAttribute */\n        ) // filter to only keep props that should match attributes\n        .map(function (_a) {\n          var propName = _a[0],\n              m = _a[1];\n          var attrName = m[1] || propName;\n          attrNameToPropName_1.set(attrName, propName);\n          return attrName;\n        });\n      }\n  }\n\n  return Cstr;\n};\n\nvar initializeComponent = function initializeComponent(elm, hostRef, cmpMeta, hmrVersionId, Cstr) {\n  return __awaiter(void 0, void 0, void 0, function () {\n    var endLoad, endNewInstance, scopeId_1, endRegisterStyles, style_1, ancestorComponent, schedule;\n    return __generator(this, function (_a) {\n      switch (_a.label) {\n        case 0:\n          if (!((hostRef.$flags$ & 32\n          /* hasInitializedComponent */\n          ) === 0)) return [3\n          /*break*/\n          , 5]; // we haven't initialized this element yet\n\n          hostRef.$flags$ |= 32\n          /* hasInitializedComponent */\n          ; // lazy loaded components\n          // request the component's implementation to be\n          // wired up with the host element\n\n          Cstr = loadModule(cmpMeta);\n          if (!Cstr.then) return [3\n          /*break*/\n          , 2];\n          endLoad = uniqueTime();\n          return [4\n          /*yield*/\n          , Cstr];\n\n        case 1:\n          Cstr = _a.sent();\n          endLoad();\n          _a.label = 2;\n\n        case 2:\n          if (!Cstr.isProxied) {\n            proxyComponent(Cstr, cmpMeta, 2\n            /* proxyState */\n            );\n            Cstr.isProxied = true;\n          }\n\n          endNewInstance = createTime('createInstance', cmpMeta.$tagName$); // ok, time to construct the instance\n          // but let's keep track of when we start and stop\n          // so that the getters/setters don't incorrectly step on data\n\n          {\n            hostRef.$flags$ |= 8\n            /* isConstructingInstance */\n            ;\n          } // construct the lazy-loaded component implementation\n          // passing the hostRef is very important during\n          // construction in order to directly wire together the\n          // host element and the lazy-loaded instance\n\n          try {\n            new Cstr(hostRef);\n          } catch (e) {\n            consoleError(e);\n          }\n\n          {\n            hostRef.$flags$ &= ~8\n            /* isConstructingInstance */\n            ;\n          }\n          endNewInstance();\n          scopeId_1 = getScopeId(cmpMeta.$tagName$);\n          if (!(!styles.has(scopeId_1) && Cstr.style)) return [3\n          /*break*/\n          , 5];\n          endRegisterStyles = createTime('registerStyles', cmpMeta.$tagName$);\n          style_1 = Cstr.style;\n          if (!(cmpMeta.$flags$ & 8)\n          /* needsShadowDomShim */\n          ) return [3\n            /*break*/\n            , 4];\n          /* needsShadowDomShim */\n\n          return [4\n          /*yield*/\n          , import('./shadow-css-4889ae62-23996f3f.js').then(function (m) {\n            return m.scopeCss(style_1, scopeId_1, false);\n          })];\n\n        case 3:\n          style_1 = _a.sent();\n          _a.label = 4;\n\n        case 4:\n          registerStyle(scopeId_1, style_1, !!(cmpMeta.$flags$ & 1\n          /* shadowDomEncapsulation */\n          ));\n          endRegisterStyles();\n          _a.label = 5;\n\n        case 5:\n          ancestorComponent = hostRef.$ancestorComponent$;\n\n          schedule = function schedule() {\n            return scheduleUpdate(elm, hostRef, cmpMeta, true);\n          };\n\n          if (ancestorComponent && ancestorComponent['s-rc']) {\n            // this is the intial load and this component it has an ancestor component\n            // but the ancestor component has NOT fired its will update lifecycle yet\n            // so let's just cool our jets and wait for the ancestor to continue first\n            // this will get fired off when the ancestor component\n            // finally gets around to rendering its lazy self\n            // fire off the initial update\n            ancestorComponent['s-rc'].push(schedule);\n          } else {\n            schedule();\n          }\n\n          return [2\n          /*return*/\n          ];\n      }\n    });\n  });\n};\n\nvar connectedCallback = function connectedCallback(elm, cmpMeta) {\n  if ((plt.$flags$ & 1\n  /* isTmpDisconnected */\n  ) === 0) {\n    var endConnected = createTime('connectedCallback', cmpMeta.$tagName$); // connectedCallback\n\n    var hostRef_1 = getHostRef(elm);\n\n    if (!(hostRef_1.$flags$ & 1\n    /* hasConnected */\n    )) {\n      // first time this component has connected\n      hostRef_1.$flags$ |= 1\n      /* hasConnected */\n      ;\n      var hostId = void 0;\n\n      if (!hostId) {\n        // initUpdate\n        // if the slot polyfill is required we'll need to put some nodes\n        // in here to act as original content anchors as we move nodes around\n        // host element has been connected to the DOM\n        if (cmpMeta.$flags$ & 4\n        /* hasSlotRelocation */\n        || cmpMeta.$flags$ & 8\n        /* needsShadowDomShim */\n        ) {\n          setContentReference(elm);\n        }\n      }\n\n      {\n        // find the first ancestor component (if there is one) and register\n        // this component as one of the actively loading child components for its ancestor\n        var ancestorComponent = elm;\n\n        while (ancestorComponent = ancestorComponent.parentNode || ancestorComponent.host) {\n          // climb up the ancestors looking for the first\n          // component that hasn't finished its lifecycle update yet\n          if (ancestorComponent['s-p']) {\n            // we found this components first ancestor component\n            // keep a reference to this component's ancestor component\n            attachToAncestor(hostRef_1, hostRef_1.$ancestorComponent$ = ancestorComponent);\n            break;\n          }\n        }\n      } // Lazy properties\n      // https://developers.google.com/web/fundamentals/web-components/best-practices#lazy-properties\n\n      if (cmpMeta.$members$) {\n        Object.entries(cmpMeta.$members$).forEach(function (_a) {\n          var memberName = _a[0],\n              memberFlags = _a[1][0];\n\n          if (memberFlags & 31\n          /* Prop */\n          && elm.hasOwnProperty(memberName)) {\n            var value = elm[memberName];\n            delete elm[memberName];\n            elm[memberName] = value;\n          }\n        });\n      }\n\n      {\n        // connectedCallback, taskQueue, initialLoad\n        // angular sets attribute AFTER connectCallback\n        // https://github.com/angular/angular/issues/18909\n        // https://github.com/angular/angular/issues/19940\n        nextTick(function () {\n          return initializeComponent(elm, hostRef_1, cmpMeta);\n        });\n      }\n    }\n\n    endConnected();\n  }\n};\n\nvar setContentReference = function setContentReference(elm) {\n  // only required when we're NOT using native shadow dom (slot)\n  // or this browser doesn't support native shadow dom\n  // and this host element was NOT created with SSR\n  // let's pick out the inner content for slot projection\n  // create a node to represent where the original\n  // content was first placed, which is useful later on\n  var crName = '';\n  var contentRefElm = elm['s-cr'] = doc.createComment(crName);\n  contentRefElm['s-cn'] = true;\n  elm.insertBefore(contentRefElm, elm.firstChild);\n};\n\nvar disconnectedCallback = function disconnectedCallback(elm) {\n  if ((plt.$flags$ & 1\n  /* isTmpDisconnected */\n  ) === 0) {\n    var hostRef = getHostRef(elm); // clear CSS var-shim tracking\n\n    if (plt.$cssShim$) {\n      plt.$cssShim$.removeHost(elm);\n    }\n  }\n};\n\nvar bootstrapLazy = function bootstrapLazy(lazyBundles, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  var endBootstrap = createTime();\n  var cmpTags = [];\n  var exclude = options.exclude || [];\n  var head = doc.head;\n  var customElements = win.customElements;\n  var y =\n  /*@__PURE__*/\n  head.querySelector('meta[charset]');\n  var visibilityStyle =\n  /*@__PURE__*/\n  doc.createElement('style');\n  var deferredConnectedCallbacks = [];\n  var appLoadFallback;\n  var isBootstrapping = true;\n  Object.assign(plt, options);\n  plt.$resourcesUrl$ = new URL(options.resourcesUrl || './', doc.baseURI).href;\n\n  if (options.syncQueue) {\n    plt.$flags$ |= 4\n    /* queueSync */\n    ;\n  }\n\n  lazyBundles.forEach(function (lazyBundle) {\n    return lazyBundle[1].forEach(function (compactMeta) {\n      var cmpMeta = {\n        $flags$: compactMeta[0],\n        $tagName$: compactMeta[1],\n        $members$: compactMeta[2],\n        $listeners$: compactMeta[3]\n      };\n      {\n        cmpMeta.$members$ = compactMeta[2];\n      }\n\n      if (!supportsShadowDom && cmpMeta.$flags$ & 1\n      /* shadowDomEncapsulation */\n      ) {\n          cmpMeta.$flags$ |= 8\n          /* needsShadowDomShim */\n          ;\n        }\n\n      var tagName = cmpMeta.$tagName$;\n\n      var HostElement =\n      /** @class */\n      function (_super) {\n        __extends(HostElement, _super); // StencilLazyHost\n\n\n        function HostElement(self) {\n          var _this = // @ts-ignore\n          _super.call(this, self) || this;\n\n          self = _this;\n          registerHost(self);\n\n          if (cmpMeta.$flags$ & 1\n          /* shadowDomEncapsulation */\n          ) {\n              // this component is using shadow dom\n              // and this browser supports shadow dom\n              // add the read-only property \"shadowRoot\" to the host element\n              if (supportsShadowDom) {\n                self.attachShadow({\n                  'mode': 'open'\n                });\n              } else if (!('shadowRoot' in self)) {\n                self.shadowRoot = self;\n              }\n            }\n\n          return _this;\n        }\n\n        HostElement.prototype.connectedCallback = function () {\n          var _this = this;\n\n          if (appLoadFallback) {\n            clearTimeout(appLoadFallback);\n            appLoadFallback = null;\n          }\n\n          if (isBootstrapping) {\n            // connectedCallback will be processed once all components have been registered\n            deferredConnectedCallbacks.push(this);\n          } else {\n            plt.jmp(function () {\n              return connectedCallback(_this, cmpMeta);\n            });\n          }\n        };\n\n        HostElement.prototype.disconnectedCallback = function () {\n          var _this = this;\n\n          plt.jmp(function () {\n            return disconnectedCallback(_this);\n          });\n        };\n\n        HostElement.prototype['s-hmr'] = function (hmrVersionId) {};\n\n        HostElement.prototype.forceUpdate = function () {\n          forceUpdate(this, cmpMeta);\n        };\n\n        HostElement.prototype.componentOnReady = function () {\n          return getHostRef(this).$onReadyPromise$;\n        };\n\n        return HostElement;\n      }(HTMLElement);\n\n      cmpMeta.$lazyBundleIds$ = lazyBundle[0];\n\n      if (!exclude.includes(tagName) && !customElements.get(tagName)) {\n        cmpTags.push(tagName);\n        customElements.define(tagName, proxyComponent(HostElement, cmpMeta, 1\n        /* isElementConstructor */\n        ));\n      }\n    });\n  }); // visibilityStyle.innerHTML = cmpTags.map(t => `${t}:not(.hydrated)`) + '{display:none}';\n\n  visibilityStyle.innerHTML = cmpTags + '{visibility:hidden}.hydrated{visibility:inherit}';\n  visibilityStyle.setAttribute('data-styles', '');\n  head.insertBefore(visibilityStyle, y ? y.nextSibling : head.firstChild); // Process deferred connectedCallbacks now all components have been registered\n\n  isBootstrapping = false;\n\n  if (deferredConnectedCallbacks.length > 0) {\n    deferredConnectedCallbacks.forEach(function (host) {\n      return host.connectedCallback();\n    });\n  } else {\n    plt.jmp(function () {\n      return appLoadFallback = setTimeout(appDidLoad, 30, 'timeout');\n    });\n  } // Fallback appLoad event\n\n\n  endBootstrap();\n};\n\nvar createEvent = function createEvent(ref, name, flags) {\n  var elm = getElement(ref);\n  return {\n    emit: function emit(detail) {\n      return elm.dispatchEvent(new CustomEvent(name, {\n        bubbles: !!(flags & 4\n        /* Bubbles */\n        ),\n        composed: !!(flags & 2\n        /* Composed */\n        ),\n        cancelable: !!(flags & 1\n        /* Cancellable */\n        ),\n        detail: detail\n      }));\n    }\n  };\n};\n\nvar getElement = function getElement(ref) {\n  return getHostRef(ref).$hostElement$;\n};\n\nexport { patchEsm as a, bootstrapLazy as b, createEvent as c, h, patchBrowser as p, registerInstance as r };"],"sourceRoot":""}